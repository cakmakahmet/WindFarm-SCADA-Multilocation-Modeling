# -*- coding: utf-8 -*-
"""RandomForestFinal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GwpfNmD50NiLhtRzSLz_opuvS8B5Z_35

Random Forest + FE + normalize edilmiş dataset
"""

import pandas as pd
import numpy as np
import time
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

from google.colab import drive
drive.mount('/content/drive')

"""Parametreler, dosya yükleme işlemleri, dosya içeriği doğrulama"""

test_size = 0.2
dosya_yolu =  "/content/drive/MyDrive/All_Combined.csv"
data = pd.read_csv(dosya_yolu, parse_dates=["Time"])
if "Location" not in data.columns:
  print("'Location' kolonu dosyada bulunamadı!")
print(f"Birleştirilmiş veri seti yülendi. Toplam satır: {data.shape[0]}\n")

"""feature engineering ve temizlik yapıyoruz. Bu modelde de location bazlı gruplama yapmalıyız."""

gr = data.groupby("Location", group_keys=False)
data["Power_lag1"] = gr["Power"].shift(1)
data["Power_lag24"] = gr["Power"].shift(24)
data["Power_rollmean3"] = gr["Power"].shift(1).rolling(3).mean()
data["Power_rollmeansdt3"] = gr["Power"].shift(1).rolling(24).mean()

data["hour"] = data["Time"].dt.hour
data["dayofweek"] = data["Time"].dt.dayofweek
data["month"] = data["Time"].dt.month

"""X ve y'leri -girdi ve çıktıların sütunlarını- ayıralım ki her biri bir özellik olarak atfedilsin."""

X = data.drop(columns=["Time", "Power"]).copy()
y = data["Power"].copy()

"""boşluk vs. temizliği yapmalıyız. Eğitimde hata almayız ancak metrik artefak sorunuyka karşılaşabiliriz."""

obje_kolonlar = X.select_dtypes(include=["object"])
if len(obje_kolonlar) > 0:
  X[obje_kolonlar] = X[obje_kolonlar].apply(pd.to_numeric, errors="coerce")
X = X.replace([np.inf, -np.inf], np.nan)
maske = X.notna().all(axis=1) & y.notna()
X = X.loc[maske].reset_index(drop=True)
y = y.loc[maske].reset_index(drop=True)

"""Test-Train bölmesini zaman sıralı biçimde bölmemiz gerekiyor. Zaman serisi analizinde en önemli noktalardan biri ise verisetinin bölünme oranı ve biçimi."""

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=test_size, shuffle=False
)
print(f"Eğitim seti boyutu (X_train): {X_train.shape[0]}")
print(f"Test seti boyutu (X_test): {X_test.shape[0]}\n")

"""Artık modeli tanımlama ve eğitme aşamasına geçebiliriz."""

rf_model = RandomForestRegressor(
    n_estimators=300,
    max_depth = 15,
    min_samples_leaf = 5,
    random_state = 42,
    n_jobs = -1
)
print("Random Forest eğitimi başlatılıyor...")
start_time = time.time()
rf_model.fit(X_train, y_train)
end_time = time.time()
print(f"Eğitim tamamlandı. Süre:{end_time - start_time: .2f} saniye")

"""tahmin ve metrik hesaplama"""

y_pred_rf = rf_model.predict(X_test)
mae_rf = mean_absolute_error(y_test, y_pred_rf)
rmse_rf = np.sqrt(mean_squared_error(y_test, y_pred_rf))
r2_rf = r2_score(y_test, y_pred_rf)

print("\n Random Forest Model Metrikleri ")
print(f"MAE (Ort. Mutlak Hata):  {mae_rf:.6f}")
print(f"RMSE (K.K. Ort. Hata): {rmse_rf:.6f}")
print(f"R² (Belirleme Katsayısı):   {r2_rf:.4f}")

"""
Random Forest + NOT FE + normalize edilmiş dataset"""

import pandas as pd
import numpy as np
import time
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

from google.colab import drive
drive.mount('/content/drive')

"""dosya yükleme ve içeriğinin kontrolünü sağlıyoruz."""

test_size = 0.2
dosya_yolu =  "/content/All_Combined.csv"
data = pd.read_csv(dosya_yolu, parse_dates=["Time"])
if "Location" not in data.columns:
  print("'Location' kolonu dosyada bulunamadı!")
print(f"Birleştirilmiş veri seti yülendi. Toplam satır: {data.shape[0]}\n")

"""X ve y'leri -girdi ve çıktıların sütunlarını- ayıralım ki her biri bir özellik olarak atfedilsin."""

X = data.drop(columns=["Time", "Power"]).copy()
y = data["Power"].copy()

"""boşluk vs. temizliği yapmalıyız. Eğitimde hata almayız ancak metrik artefak sorunuyka karşılaşabiliriz.


"""

obje_kolonlar = X.select_dtypes(include=["object"])
if len(obje_kolonlar) > 0:
  X[obje_kolonlar] = X[obje_kolonlar].apply(pd.to_numeric, errors="coerce")
X = X.replace([np.inf, -np.inf], np.nan)
maske = X.notna().all(axis=1) & y.notna()
X = X.loc[maske].reset_index(drop=True)
y = y.loc[maske].reset_index(drop=True)

"""Test-Train bölmesini zaman sıralı biçimde bölmemiz gerekiyor. Zaman serisi analizinde en önemli noktalardan biri ise verisetinin bölünme oranı ve biçimi."""

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=test_size, shuffle=False
)
print(f"Eğitim seti boyutu (X_train): {X_train.shape[0]}")
print(f"Test seti boyutu (X_test): {X_test.shape[0]}\n")
print("Özellik sayısı:", X_train.shape[1])

"""Artık modeli tanımlama ve eğitme aşamasına geçebiliriz."""

rf_model = RandomForestRegressor(
    n_estimators=300,
    max_depth = 15,
    min_samples_leaf = 5,
    random_state = 42,
    n_jobs = -1
)
print("Random Forest eğitimi başlatılıyor...")
start_time = time.time()
rf_model.fit(X_train, y_train)
end_time = time.time()
print(f"Eğitim tamamlandı. Süre:{end_time - start_time: .2f} saniye")

"""tahmin ve metrik hesaplama"""

y_pred_rf = rf_model.predict(X_test)
mae_rf = mean_absolute_error(y_test, y_pred_rf)
rmse_rf = np.sqrt(mean_squared_error(y_test, y_pred_rf))
r2_rf = r2_score(y_test, y_pred_rf)

print("\n Random Forest Model Metrikleri ")
print(f"MAE (Ort. Mutlak Hata):  {mae_rf:.6f}")
print(f"RMSE (K.K. Ort. Hata): {rmse_rf:.6f}")
print(f"R² (Belirleme Katsayısı):   {r2_rf:.4f}")

"""Random Forest + FE + direkt SCADA türbin verisinin meteorolojik verilerle çeşitlendirilmiş hali"""

import pandas as pd
import numpy as np
import time

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

dosya_yolu = "/content/T1_merged_meteo.csv"

df = pd.read_csv(dosya_yolu)
print("Ham veri şekli:", df.shape)
print("Sütunlar:", df.columns.tolist())

df["Time"] = pd.to_datetime(df["Time"])
df = df.sort_values("Time").reset_index(drop=True)

data = df.copy()

# İsimleri basitleştirdik
data = data.rename(columns={
    "LV ActivePower (kW)": "Power",
    "Date/Time": "Time"   # yoksa bir şey olmaz
})

data["Time"] = pd.to_datetime(data["Time"])

# FEATURE ENGINEERING

data = df.copy()

# İsimleri standardize et
data = data.rename(columns={
    "LV ActivePower (kW)": "Power",
    "Date/Time": "Time"   # yoksa bir şey olmaz
})

# Time kolonunu garantiye al
data["Time"] = pd.to_datetime(data["Time"])

print("Başlangıç shape:", data.shape)

# Start/stop gürültüsü filtresi
# Gerekirse eşiği düşürebilirsin (örn. > 10)
data = data[data["Power"] > 50]
print("Power>50 filtresi sonrası:", data.shape)

# Power türev ve lag'ler
data["dPower"]      = data["Power"].diff()
data["Power_lag1"]  = data["Power"].shift(1)
data["Power_lag6"]  = data["Power"].shift(6)      # ~1 saat
data["Power_lag24"] = data["Power"].shift(24)     # ~4 saat

# Rolling ortalama / std
data["Power_roll6"] = (
    data["Power"]
      .shift(1)
      .rolling(6)
      .mean()
)

data["Power_roll12"] = (
    data["Power"]
      .shift(1)
      .rolling(12)
      .mean()
)

data["Power_rollstd6"] = (
    data["Power"]
      .shift(1)
      .rolling(6)
      .std()
)

#Rüzgar hızı feature'ları
if "Wind Speed (m/s)" in data.columns:
    data["dWind"] = data["Wind Speed (m/s)"].diff()

    data["Wind_rollmean3"] = (
        data["Wind Speed (m/s)"]
          .shift(1)
          .rolling(3)
          .mean()
    )

    data["Wind_rollstd3"] = (
        data["Wind Speed (m/s)"]
          .shift(1)
          .rolling(3)
          .std()
    )

    data["Wind3"] = data["Wind Speed (m/s)"] ** 3

# Rüzgar yönü sin/cos
if "Wind Direction (°)" in data.columns:
    data["wind_sin"] = np.sin(np.deg2rad(data["Wind Direction (°)"]))
    data["wind_cos"] = np.cos(np.deg2rad(data["Wind Direction (°)"]))

# Zaman feature'ları
data["hour"]      = data["Time"].dt.hour
data["dayofweek"] = data["Time"].dt.dayofweek
data["month"]     = data["Time"].dt.month
data["dayofyear"] = data["Time"].dt.dayofyear

# ERA5 meteo feature'ları (varsa)
if "windspeed_100m" in data.columns:
    data["era_ws100"]   = data["windspeed_100m"]
    data["era_ws100_3"] = data["windspeed_100m"] ** 3

if "windspeed_10m" in data.columns:
    data["era_ws10"] = data["windspeed_10m"]

if "winddirection_10m" in data.columns:
    data["era_wd_sin"] = np.sin(np.deg2rad(data["winddirection_10m"]))
    data["era_wd_cos"] = np.cos(np.deg2rad(data["winddirection_10m"]))

if "windgusts_10m" in data.columns:
    data["era_gust"] = data["windgusts_10m"]

if "temperature_2m" in data.columns:
    data["era_temp2"] = data["temperature_2m"]

if "relativehumidity_2m" in data.columns:
    data["era_rh2"] = data["relativehumidity_2m"]

if "dewpoint_2m" in data.columns:
    data["era_dew2"] = data["dewpoint_2m"]

# Hava yoğunluğu
R = 287.05
if "pressure_msl" in data.columns and "temperature_2m" in data.columns:
    data["air_density"] = (data["pressure_msl"] * 100) / (R * (data["temperature_2m"] + 273.15))

# Tamamen NaN kolonları temizle
# (örneğin tüm satırlarda NaN olan 80m vs. kolonları otomatik siler)
data = data.dropna(axis=1, how="all")

# Lag/rolling nedeniyle ilk örnekleri at
# En büyük lag 24 olduğu için ilk 24 satırı güvenli şekilde atıyoruz
data = data.iloc[24:].copy()

# Kalan NaN'leri satır bazında temizle
data = data.dropna().reset_index(drop=True)

print("FE sonrası veri şekli:", data.shape)
print("Kalan kolon sayısı:", len(data.columns))
print("Kolonlar:", data.columns.tolist())

# X, y OLUŞTURMA ve TRAIN / VAL / TEST AYRIMI

hedef_sutun = "Power"
tarih_sutun = "Time"

# Özellik kolonları: zaman ve hedef hariç her şey
ozellik_sutunlar = [c for c in data.columns if c not in [hedef_sutun, tarih_sutun]]

X = data[ozellik_sutunlar].values
y = data[hedef_sutun].values

n = len(data)
train_end = int(n * 0.70)
val_end   = int(n * 0.85)   # %70 train, %15 val, %15 test

X_train, y_train = X[:train_end], y[:train_end]
X_val,   y_val   = X[train_end:val_end], y[train_end:val_end]
X_test,  y_test  = X[val_end:], y[val_end:]

print(f"Toplam örnek sayısı: {n}")
print(f"Train: {len(X_train)}, Val: {len(X_val)}, Test: {len(X_test)}")
print("Özellik sayısı:", X_train.shape[1])

import time

#RANDOM FOREST MODELİNİ EĞİTME

rf_model = RandomForestRegressor(
    n_estimators=300,
    max_depth=15,
    min_samples_split=10,
    min_samples_leaf=5,
    bootstrap=True,
    random_state=42,
    n_jobs=-1
)
print("Random Forest eğitimi başlatılıyor...")
start_time = time.time()
rf_model.fit(X_train, y_train)
end_time = time.time()
print(f"Eğitim tamamlandı. Süre:{end_time - start_time: .2f} saniye")

def evaluate(name, y_true, y_pred):
    mae  = mean_absolute_error(y_true, y_pred)
    rmse = mean_squared_error(y_true, y_pred) ** 0.5
    r2   = r2_score(y_true, y_pred)
    print(f"{name:<10} → MAE: {mae:.3f}, RMSE: {rmse:.3f}, R2: {r2:.4f}")

# VALIDATION
y_val_pred = rf_model.predict(X_val)
print("VALIDATION SONUÇLARI")
evaluate("RF (val)", y_val, y_val_pred)

# TEST
y_test_pred = rf_model.predict(X_test)
print("TEST SONUÇLARI")
evaluate("RF (test)", y_test, y_test_pred)

#RANDOM FOREST İÇİNDEN PROBABILISTIC (QUANTILE) ÇIKARMA

import numpy as np

# Ormandaki ağaç sayısı
n_trees = len(rf_model.estimators_)
print("Ağaç sayısı:", n_trees)

# Her ağaç için test seti tahmini: shape → (n_samples, n_trees)
all_tree_preds = np.zeros((X_test.shape[0], n_trees))

for i, tree in enumerate(rf_model.estimators_):
    all_tree_preds[:, i] = tree.predict(X_test)

print("all_tree_preds shape:", all_tree_preds.shape)

# Quantile'lar (0.05, 0.5, 0.95)
q_levels = [0.05, 0.5, 0.95]
y_q05 = np.quantile(all_tree_preds, 0.05, axis=1)
y_q50 = np.quantile(all_tree_preds, 0.50, axis=1)
y_q95 = np.quantile(all_tree_preds, 0.95, axis=1)

print("Quantile tahminler üretildi.")

#PROBABILISTIC TAHMİN GRAFİĞİ

import matplotlib.pyplot as plt

n_plot = 300
t = np.arange(n_plot)

plt.figure(figsize=(16, 6))

plt.plot(t, y_test[:n_plot], label="Gerçek Power", linewidth=1)
plt.plot(t, y_q50[:n_plot], label="RF Medyan Tahmin (q=0.5)", linewidth=1)

plt.plot(t, y_q05[:n_plot], label="Alt Band (q=0.05)", linestyle="--")
plt.plot(t, y_q95[:n_plot], label="Üst Band (q=0.95)", linestyle="--")

plt.fill_between(t, y_q05[:n_plot], y_q95[:n_plot], alpha=0.2, label="%90 Band")

plt.title("Random Forest Probabilistic Tahmin (Ağaç Dağılımından Quantile)")
plt.xlabel("Test örnek indexi")
plt.ylabel("Power (kW)")
plt.legend()
plt.grid(True)
plt.show()

#KAPSAMA ORANI HESABI

inside_band = (y_test >= y_q05) & (y_test <= y_q95)
coverage = inside_band.mean() * 100

print(f"%90 bandının gerçek kapsaması: %{coverage:.2f}")

"""Random Forest + NOT FE + direkt SCADA türbin verisinin meteorolojik verilerle çeşitlendirilmiş hali"""

import pandas as pd
import numpy as np
import time

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

dosya_yolu = "/content/T1_merged_meteo.csv"

df = pd.read_csv(dosya_yolu)
print("Ham veri şekli:", df.shape)
print("Sütunlar:", df.columns.tolist())

df["Time"] = pd.to_datetime(df["Time"])
df = df.sort_values("Time").reset_index(drop=True)

df = df.rename(columns={
    "LV ActivePower (kW)": "Power",
    "ActivePower": "Power",
    "Date/Time": "Time",
    "DATE_TIME": "Time"
})

hedef_sutun = "Power"
tarih_sutun = "Time"

# Time ve Power dışındaki her şeyi feature olarak al
X = df.drop(columns=[tarih_sutun, hedef_sutun]).copy()
y = df[hedef_sutun].copy()

# X, y OLUŞTURMA (FE YOK + GÜVENLİ TEMİZLİK)

# Power ve Time dışındaki tüm feature'lar:
X = df.drop(columns=["Time", "Power"]).copy()
y = df["Power"].copy()

print("Başlangıç X shape:", X.shape)

# 1) Tamamen NaN kolonları sil
X = X.dropna(axis=1, how="all")
print("Tamamen NaN kolonlar temizlendi. X shape:", X.shape)

# 2) INF → NaN
X = X.replace([np.inf, -np.inf], np.nan)

# 3) Çok fazla NaN içeren kolonları sil (ör: %40'tan fazla)
threshold = 0.40
column_valid_ratio = X.notna().mean()

cols_to_drop = column_valid_ratio[column_valid_ratio < (1 - threshold)].index.tolist()
if len(cols_to_drop) > 0:
    print("Aşırı eksik kolonlar silindi:", cols_to_drop)
    X = X.drop(columns=cols_to_drop)

print("Eksik kolon temizliği sonrası X shape:", X.shape)

# 4) Satır bazlı NaN temizliği (ama tüm veriyi silmeyecek)
X = X.dropna().reset_index(drop=True)
y = y.loc[X.index]  # Y'yi de hizalıyoruz

print("Son temizlenmiş X shape:", X.shape)
print("Son temizlenmiş y shape:", y.shape)

n = len(X)
train_end = int(n * 0.70)
val_end   = int(n * 0.85)   # %70 train, %15 val, %15 test

X_train, y_train = X.iloc[:train_end].values, y.iloc[:train_end].values
X_val,   y_val   = X.iloc[train_end:val_end].values, y.iloc[train_end:val_end].values
X_test,  y_test  = X.iloc[val_end:].values, y.iloc[val_end:].values

print(f"Toplam örnek sayısı: {n}")
print(f"Train: {len(X_train)}, Val: {len(X_val)}, Test: {len(X_test)}")
print("Özellik sayısı:", X_train.shape[1])

rf_model = RandomForestRegressor(
    n_estimators=300,
    max_depth=15,
    min_samples_split=10,
    min_samples_leaf=5,
    bootstrap=True,
    random_state=42,
    n_jobs=-1
)

print("Random Forest eğitimi başlatılıyor...")
start_time = time.time()
rf_model.fit(X_train, y_train)
end_time = time.time()
print(f"Eğitim tamamlandı. Süre: {end_time - start_time: .2f} saniye")

def evaluate(name, y_true, y_pred):
    mae  = mean_absolute_error(y_true, y_pred)
    rmse = mean_squared_error(y_true, y_pred) ** 0.5
    r2   = r2_score(y_true, y_pred)
    print(f"{name:<10} → MAE: {mae:.3f}, RMSE: {rmse:.3f}, R2: {r2:.4f}")

# VALIDATION
y_val_pred = rf_model.predict(X_val)
print("VALIDATION SONUÇLARI")
evaluate("RF (val)", y_val, y_val_pred)

# TEST
y_test_pred = rf_model.predict(X_test)
print("\n TEST SONUÇLARI")
evaluate("RF (test)", y_test, y_test_pred)

import numpy as np

# Ormandaki ağaç sayısı
n_trees = len(rf_model.estimators_)
print("Ağaç sayısı:", n_trees)

# Her ağaç için test seti tahmini: shape → (n_samples, n_trees)
all_tree_preds = np.zeros((X_test.shape[0], n_trees))

for i, tree in enumerate(rf_model.estimators_):
    all_tree_preds[:, i] = tree.predict(X_test)

print("all_tree_preds shape:", all_tree_preds.shape)

# Quantile'lar (0.05, 0.5, 0.95)
y_q05 = np.quantile(all_tree_preds, 0.05, axis=1)
y_q50 = np.quantile(all_tree_preds, 0.50, axis=1)
y_q95 = np.quantile(all_tree_preds, 0.95, axis=1)

print("Quantile tahminler üretildi (q05, q50, q95).")

import matplotlib.pyplot as plt

n_plot = 300   # istersen 500 yapabilirsin
t = np.arange(n_plot)

plt.figure(figsize=(16, 6))

plt.plot(t, y_test[:n_plot], label="Gerçek Power", linewidth=1)
plt.plot(t, y_q50[:n_plot], label="RF Medyan Tahmin (q=0.5)", linewidth=1)

plt.plot(t, y_q05[:n_plot], label="Alt Band (q=0.05)", linestyle="--")
plt.plot(t, y_q95[:n_plot], label="Üst Band (q=0.95)", linestyle="--")

plt.fill_between(t, y_q05[:n_plot], y_q95[:n_plot],
                 alpha=0.2, label="%90 Band")

plt.title("FE'siz RF – Probabilistic Tahmin (Ağaç Dağılımından Quantile)")
plt.xlabel("Test örnek indexi")
plt.ylabel("Power (kW)")
plt.legend()
plt.grid(True)
plt.show()

inside_band = (y_test >= y_q05) & (y_test <= y_q95)
coverage = inside_band.mean() * 100

print(f"%90 bandının gerçek kapsaması: %{coverage:.2f}")